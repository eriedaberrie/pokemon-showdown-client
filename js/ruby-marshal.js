/**
 * Marshal Reader
 *
 * A reader for marshal files generated by Ruby in Javascript
 * Follows https://docs.ruby-lang.org/en/master/doc/marshal_rdoc.html
 *
 * @author eriedaberrie
 */

(function (exports) {
	'use strict';

	function MarshalReader(stream) {
		this._streamview = new DataView(stream);
		this._index = 0;
	};

	MarshalReader.prototype.readSingle = function () {
		if ((this._streamview.getUint16(this._index) === 0x0408)) {
			this._syms = [];
			this._objs = [];
			this._index += 2;
			return this._getItem();
		} else {
			throw 'Invalid marshal file version number';
		}
	};

	MarshalReader.prototype.readAll = function () {
		var ret = [];
		this._index = 0;

		while (this._index < this._streamview.byteLength) {
			ret.push(this.readSingle());
		}

		return ret;
	};

	MarshalReader.prototype._getItem = function () {
		var typecode = this._streamview.getUint8(this._index++);
		switch (typecode) {
			case 0x30: // 0 - nil
				return null;
			case 0x54: // T - true
				return true;
			case 0x46: // F - false
				return false;
			case 0x69: // i - integer
				return this._getInt();
			case 0x5b: // [ - array
				return this._getArray();
			case 0x7b: // { - hash
				return this._getHash();
			case 0x3a: // : - symbol
				return this._getSymbol(false);
			case 0x3b: // ; - symlink
				return this._getSymlink();
			case 0x49: // I - IVAR
				return this._getIVAR();
			case 0x22: // ' - string
				return this._getString();
			case 0x40: // @ - objlink
				return this._getObjlink();
			case 0x2f: // / - regex
				return this._getRegex(false);
			case 0x63: // c - class
			case 0x6d: // m - module
			case 0x4d: // M - class or module
				return this._getClassOrModule(false);
			case 0x6f: // o - object
			case 0x53: // S - struct
				return this._getObject();
			case 0x6c: // l - bignum
				return this._getBignum();
			case 0x66: // f - float
				return this._getFloat();
			case 0x43: // C - user subclass
				return this._getUserSubclass();
			case 0x75: // u - user-defined serialization
				return this._getUserDefined();
			default:
				throw 'Invalid typecode 0x' + typecode.toString(16) + ' at offset 0x' + (this._index - 1).toString(16) + ' (decimal ' + (this._index - 1) + ')';
		}
	};

	MarshalReader.prototype._getInt = function () {
		var firstbyte = this._streamview.getUint8(this._index++)
		var ret;
		switch (firstbyte) {
			case 0x00:
				// Is 0
				return 0;
			case 0x01:
				// 8-bit unsigned
				return this._streamview.getUint8(this._index++);
			case 0xff:
				// Negative 8-bit unsigned
				return ~(0xff ^ this._streamview.getUint8(this._index++));
			case 0x02:
				// 16-bit unsigned (little endian)
				ret = this._streamview.getUint16(this._index, true);
				this._index += 2;
				return ret;
			case 0xfe:
				// Negative 16-bit unsigned (little endian)
				ret = ~(0xffff ^ this._streamview.getUint16(this._index, true));
				this._index += 2;
				return ret;
			case 0x03:
				// 24-bit unsigned (little endian) (waht the fuck)
				ret = this._streamview.getUint8(this._index) | (this._streamview.getUint16(this._index + 1, true) << 8);
				this._index += 3;
				return ret;
			case 0xfd:
				// Negative 24-bit unsigned (little endian)
				ret = ~(0xffffff ^ (this._streamview.getUint8(this._index) | (this._streamview.getUint16(this._index + 1, true) << 8)));
				this._index += 3;
				return ret;
			case 0x04:
				// 32-bit unsigned (little endian)
				ret = this._streamview.getUint32(this._index, true);
				this._index += 4;
				return ret;
			case 0x04:
				// Negative 32-bit unsigned (little endian)
				ret = ~(0xffffffff ^ this._streamview.getUint32(this._index, true));
				this._index += 4;
				return ret;
			default:
				if (firstbyte <= 127) {
					// If positive, subtract 5
					return firstbyte - 5;
				} else {
					// If negative, actually make it negative (initially read as unsinged) and add 5
					return firstbyte - 251;
				}
		}
	};

	MarshalReader.prototype._getArray = function () {
		var itemcount = this._getInt();
		var ret = [];
		this._objs.push(ret);
		for (var i = 0; i < itemcount; i++) {
			ret.push(this._getItem());
		}
		return ret;
	};

	MarshalReader.prototype._getHash = function () {
		var itemcount = this._getInt();
		var ret = {};
		this._objs.push(ret);
		var key, value;
		for (var i = 0; i < itemcount; i++) {
			key = this._getItem();
			value = this._getItem();
			ret[key] = value;
		}
		return ret;
	};

	MarshalReader.prototype._getUtfChar = function () {
		var val = this._streamview.getUint8(this._index++);
		if (val & 0b10000000) {			// at least 2 bytes
			var val2 = this._streamview.getUint8(this._index++);
			if (val & 0b00100000) {		// at least 3 bytes
				var val3 = this._streamview.getUint8(this._index++);
				if (val & 0x00010000) {	// 4 bytes
					var val4 = this._streamview.getUint8(this._index++)
					val = ((val & 0b00000111) << 18) | ((val2 & 0b00111111) << 12) | ((val3 & 0b00111111) << 6) | (val4 & 0b00111111);
				} else {
					val = ((val & 0b00001111) << 12) | ((val2 & 0b00111111) << 6) | (val3 & 0b00111111); // 3 bytes
				}
			} else {
				val = ((val & 0b00011111) << 6) | (val2 & 0b00111111); // 2 bytes
			}
		}

		return String.fromCharCode(val);
	};

	MarshalReader.prototype._getText = function (useUTF) {
		var bytelen = this._getInt();
		var endindex = this._index + bytelen;
		var ret = '';
		while (this._index < endindex) {
			ret += (useUTF ? this._getUtfChar() : String.fromCharCode(this._streamview.getUint8(this._index++)));
		}
		return ret;
	};

	MarshalReader.prototype._getString = function (useUTF) {
		var ret = this._getText(useUTF);
		this._objs.push(ret);
		return ret;
	};

	MarshalReader.prototype._getSymbol = function (useUTF) {
		var ret = this._getText(useUTF);
		this._syms.push(ret);
		return ret;
	};

	MarshalReader.prototype._getRegex = function (useUTF) {
		var ret = new RegExp(this._getText(useUTF));
		this._objs.push(ret)
		this.index++; // Can't be bothered to deal with regex options atm
		return ret;
	};

	MarshalReader.prototype._getSymlink = function () {
		return this._syms[this._getInt()];
	};

	MarshalReader.prototype._getObjlink = function () {
		return this._objs[this._getInt()];
	};

	MarshalReader.prototype._getIVAR = function () {
		// Scuffed but working well enough
		// Theres more with actual impacts but the relevant ones are for encoding
		// Everything else just gets ignored/throws an error
		// This uses a pretty roundabout to ensure the string encoding works:
		// First it skips ahead to look at the ivar, then goes back to actually read the symbol/string
		var firstbyte = this._streamview.getUint8(this._index++)
		var startindex = this._index; // the start value of the instance
		var ret, offset, varnum, key, value, endindex;
		switch (firstbyte) {
			case 0x3a: // : - symbol
				offset = this._getInt(); // 2 lines because evaluating the offset changes the index
				this._index += offset;
				varnum = this._getInt();
				if (varnum === 1) {
					// Forcefully get string to cache symbols in the right order, don't do anything for symlinks
					var notsymlink = (this._streamview.getUint8(this._index++) === 0x3a);
					key = (notsymlink ? this._getText() : this._getSymlink());
					value = this._getItem();
					endindex = this._index;
					this._index = startindex;
					switch (key) {
						case 'E':
							ret = this._getSymbol(value);
							break;
						case 'encoding':
							ret = this._getSymbol(false);
							break;
						default:
							throw 'Invalid instance variable key: ' + key + ' => ' + value;
					}
					if (notsymlink) this._syms.push(key);
					this._index = endindex;
				} else {
					throw 'Has  ' + varnum + ' instance variables instead of 1';
				}
				break;
			case 0x22: // ' - string
				offset = this._getInt();
				this._index += offset;
				varnum = this._getInt();
				if (varnum === 1) {
					key = this._getItem();
					value = this._getItem();
					endindex = this._index;
					this._index = startindex;
					switch (key) {
						case 'E':
							ret = this._getString(value);
							break;
						case 'encoding':
							ret = this._getString(false);
							break;
						default:
							throw 'Invalid instance variable key: ' + key + ' => ' + value;
					}
					this._index = endindex;
				} else {
					throw 'Has  ' + varnum + ' instance variables instead of 1';
				}
				break;
			case 0x2f: // / - regex
				offset = this._getInt();
				this._index += offset + 1; // Skip past the options identifier
				varnum = this._getInt();
				if (varnum === 1) {
					key = this._getItem();
					value = this._getItem();
					endindex = this._index;
					this._index = startindex;
					switch (key) {
						case 'E':
							ret = this._getRegex(value);
							break;
						case 'encoding':
							ret = this._getRegex(false);
							break;
						default:
							throw 'Invalid instance variable key: ' + key + ' => ' + value;
					}
					this._index = endindex;
				} else {
					throw 'Has  ' + varnum + ' instance variables instead of 1';
				}
				break;
			case 0x75: // u - user-defined serialization
				this._index--;
				ret = this._getItem();
				varnum = this._getInt();
				for (var i = 0; i < varnum; i++) {
					key = this._getItem();
					ret[key] = this._getItem();
				}
				break;
			default: // Just ignore em, try not to break any code.
				this._index--;
				ret = this._getItem();
				varnum = this._getInt() * 2;
				for (var i = 0; i < varnum; i++) {
					this._getItem();
				}
				// throw 'IVAR for something other than symbols/strings/regex';
		}
		return ret;
	};

	MarshalReader.prototype._getObject = function () {
		var name = this._getItem();
		// This is fine because getHash() pushes to _objs
		var ret = this._getHash();
		ret._name = name;
		return ret;
	};

	MarshalReader.prototype._getBignum = function () {
		var isnegative = (this._streamview.getUint8(this._index++) === 0x2d);
		var bytelen = BigInt(this._getInt() * 2);
		var ret = 0;
		// using bitwise operations would result in negatives (gotta love javascript)
		for (var i = 0; i < bytelen; i++) {
			ret += this._streamview.getUint8(this._index++) * 2 ** (i * 8);
		}
		if (isnegative) ret *= -1;
		return ret;
	};

	MarshalReader.prototype._getFloat = function () {
		var floatstr = this._getText(false);
		switch (floatstr) {
			case 'inf':
				return Infinity;
			case '-inf':
				return -Infinity;
			case 'nan':
				return NaN;
			default:
				return parseFloat(floatstr);
		}
	};

	MarshalReader.prototype._getUserSubclass = function () {
		this._getItem(); // Don't really care about name, might mess up hashes anyways (somehow) (record it in the cache tho)
		return this._getItem();
	};

	MarshalReader.prototype._getUserDefined = function () {
		var name = this._getItem();
		var ret = {
			_content: this._getText(false),
			_uname: name,
		};
		this._objs.push(ret);
		return ret;
	};

	MarshalReader.prototype._getClassOrModule = MarshalReader.prototype._getString; // DO record the name in _objs

	exports.MarshalReader = MarshalReader;

})(window);